# Язык программирования Math#

**Math#** – это минималистичный функциональный язык программирования с синтаксисом, максимально похожим на математические записи:
- функции (в том числе кусочные) задаются формулами
- есть математические множества и типы (`N`, `Z`, `Q`, `R`, `{0,1}`)
- символы возведения в степень `^`, модуль `|-x|` и факториал `!`
- рекурсия и функции высшего порядка
- списки и базовые операции над ними
- простая статическая проверка типов.

Файлы языка имеют **расширение** `.ms`

---

## Пример вычисления числа фибоначчи

**Математическая формула**

$$
F(n) =
\begin{cases}
0, \text{ } n = 0 \\
1, \text{ } n = 1 \\
F(n-1) + F(n-2), \text{ } n \ge 2
\end{cases}
$$

**Код на Math#**
```math#
F: N -> N
F(n) = {
    0, n = 0
    1, n = 1
    F(n-1) + F(n-2), n >= 2
}

main() = F(10)
```

---

## Быстрый старт
1) Склонируйте репозиторий
2) Откройте терминал в корне проекта
3) Выполните следующие команды
```shell
dotnet build
cd MathSharp/bin/Debug/net8.0/
./MathSharp Examples/fib.ms
```

4) В результате вы должны увидеть `Fibonacci 10th = 55`.

Альтарнативный вариант запуска – указать путь к файлу в конфигурации запуска проекта в IDE.
Для **Rider**: Run –> Edit Configurations... –> Program arguments: `Examples/fib.ms`.

> Вместо `fib.ms` можете выбрать любой понравившийся пример из папки `MathSharp/Examples`.

---

# Авторы
| Имя             | Роль в проекте                                                                                       |
|-----------------|------------------------------------------------------------------------------------------------------|
| Бакланов Егор   | Написание парсера и интерпретатора, а также реализация проверки типов (+документация)                |
| Оганесян Микаэл | Реализация абстрактного синтаксического дерева, написание стандартной библиотеки и руководства к ним |

---

## Реализованные требования
- Именованные переменные (let). Реализовано через имя = выражение на верхнем уровне (`gauss.ms`).
- Рекурсия. Функции могут вызывать себя и другие функции (`fib.ms`).
- Функции. Есть именованные и анонимные функции, поддерживаются функции высшего порядка (`taylor.ms`).
- Замыкания. Анонимные функции и функции как значения хранятся вместе с окружением определения, что дает замыкания (`char.ms`).
- Библиотечные функции: ввод-вывод файлов. Реализованы readFile и writeFile, а также текстовый ввод/вывод (`io.ms`).
- Списки / Последовательности. Есть списки, литералы, базовые операции (`bubbleSort.ms`).
- Библиотечные функции: списки/последовательности. Поддерживаются map, fold и простые функции над списками (`lists.ms`).

Иными словами, есть все, кроме ленивости (из условия дз).

---

# Документация

**Math#** использует функциональную модель вычислений, в которой именованные и анонимные функции интерпретируются как лямбда-выражения, а выполнение программы соответствует $\beta$-редукции с учетом окружения. Язык не является чистым $\lambda$-исчислением, но расширяет его практическими конструкциями: типами, списками, операциями, встроенными функциями, кусочными определениями.

## Типы и множества

В языке есть предопределенные математические типы:
- `N` – натуральные числа (по модели: неотрицательные, аналог `uint`)
- `Z` – целые числа (аналог `int`)
- `Q` – рациональные числа (обобщенное "целое/натуральное с делением")
- `R` – вещественные числа (аналог `float`)
- `{0, 1}` – двоичный набор, интерпретируется как булев тип
- `Bool` – явный булев тип (синоним `{0, 1}`)
- `String` – строки.

---

## Простая статическая типизация

В языке реализована базовая проверка типов перед выполнением программы.

Числа упорядочены по "ширине": $\mathbb{N} \subseteq \mathbb{Z} \subseteq \mathbb{Q} \subseteq \mathbb{R}$

Тип чисел можно расширять (например, `N` –> `R`), но нельзя сужать (`Z` -x-> `N`).

### Вывод типов литералов
- `IntLit` (например, 10) –> `N`
- унарный `-` делает тип `Z` (-10 –> `Z`)
- `RealLit` (например, 3.14) –> `R`
- `true`/`false` –> `Bool`
- `{0, 1}` в сигнатуре интерпретируется как `Bool`.

### Проверка функций

Для каждой функции учитываются: сигнатура `F: A -> B` (если есть) и аннотации типов параметров `F(x: T)`.

Проверяется:
- совпадение количества аргументов
- совместимость типов аргументов с ожидаемыми
- для кусочных функций – согласованность типов всех веток
- соответствие типа тела функции объявленному типу B.

---

## Выражения

### **Литералы**
- Целые: `0`, `1`, `42` –> по умолчанию тип `N`
- Вещественные: `0.0`, `3.14` –> тип `R`
- Булевы: `true`, `false`
- Строки: `"hello"`
- Списки: `[]`, `[1, 2, 3]`, `[x, y, 2*x]`

### **Переменные и вызов функций**
```math#
x
f(x)
g(x, y, z)
sqrt(2 * PI)
```

### Арифметика и приоритеты

Поддерживаются операции:
- бинарные: `+` `-` `*` `/` `^`
- унарный: `-`
- постфиксный: `!`

Приоритеты:
1.	`!` `^`
2.	`*` `/`
3.	`+` `-`

Ассоциативность:
- `^` – правая: `x^a^b = x^(a^b)`
- `+` `-` `*` `/` – левые.

### **Модуль**
Модуль записывается в математическом виде:
```math#
|x|
|x^3 + 2*x|
|(x^2 - 1)/(x + 1)|
```

`|expr|` интерпретируется как `abs(expr)`.

### Сравнения и логика
Сравнения: `=`  `!=`  `<`  `<=`  `>`  `>=` `in`  `not in`

Логические операции: `and`  `or`  `not`

Примеры:
```math#
n = 0
x > 0 and x < 1
x in A
x not in A
not (x = y)
```

### Списки

Литералы: `[]`, `[1, 2, 3]`, `[x, y, 2*x]`

Встроенные функции:\
`head(xs)` – первый элемент списка\
`tail(xs)` – список без первого элемента\
`isEmpty(xs)` – true, если список пуст\
`cons(x, xs)` – добавить элемент в начало списка\
`map(f, xs)` – применить функцию к каждому элементу\
`fold(f, acc, xs)` – свертка списка.

### Анонимные функции
```math#
(x: R) -> x^2 + 1
(x, y: R) -> x^2 + y^2
() -> 42
```

Пример:
```math#
square(x: R) = x^2
xs = [1, 2, 3, 4]

main() = fold((acc, x: R) -> acc + x, 0, map(square, xs))
```

---

## Верхнеуровневые конструкции

### **Константы**

Формат: имя = выражение

Пример:
```math#
mu = 10
sigma = 5
```

Константа связывается один раз и далее используется как обычное имя в выражениях.

### **Сигнатуры функций**

Сигнатура функции опциональна, но используется для документации и проверки типов:
```math#
F: N -> N
X_A: X -> {0, 1}
```

Тип после `:` – это `TypeExpr`, может быть стрелочным:
- N -> N
- R -> Q
- Z -> R
- X -> {0, 1} и т.д.


### Определения функций

Обычная (одиночная) функция
```math#
f(x: R) = x^2 + 1
```
- имя: `f`
- список параметров: `(x: R)`
- тело: выражение `x^2 + 1`

Тип параметров можно опускать:
```math#
g(x) = x + 1
```

Кусочная функция задается блоком в фигурных скобках:
```math#
fact(n: N) = {
    1, n = 0
    n * fact(n-1), n > 0
}
```

Каждая строка внутри `{}`: выражение, условие

Условия проверяются сверху вниз, выбирается первая подходящая ветка.
Есть специальное условие `otherwise`:
```math#
X_A(x) = {
    true, x in A
    false, otherwise
}
```


### Точка входа

Точкой входа программы является функция `main() = ...`

Аргументы не поддерживаются.

---

## Стандартная библиотека

### Константы
`PI` – число $\pi$\
`E` – число $e$

### Математические функции
`sqrt(x: R)` – $\sqrt{x}$\
`exp(x: R)` – $e^x$

### Функции ввода-вывода
`print(x)` – вывод без перевода строки\
`println(x)` – вывод с переводом строки\
`readLine()` – чтение одной строки из stdin\
`readInt()` – чтение целого числа\
`readReal()` – чтение вещественного числа\
`readFile(path: String)` – чтение файла в строку\
`writeFile(path: String, content: String)` – запись строки в файл.

Пример:
```math#
copyFile() = writeFile("out.txt", readFile(readLine()))
main() = copyFile()
```

---

# Архитектура реализации

Реализация языка **Math#** выполнена на **F#** и состоит из нескольких модулей.

### AST (Ast.fs)
Определяет абстрактное синтаксическое дерево:
- `Expr` – выражения
- `TypeExpr` – типы
- `FuncDef`, `FuncSig`, `ConstDef` – определения
- `Program` – список верхнеуровневых определений.

### Парсер (Parser.fs)
Реализован на базе `FParsec`. Отвечает за:
- разбор программы из текста в AST
- учет приоритетов операций
- парсинг |expr|, списков, анонимных функций
- кусочные функции { ... } с ветками expr, condition.

### Проверка типов (TypeCheck.fs)
Реализует:
- внутреннее представление типов
- построение таблицы типов функций по сигнатурам и аннотациям
- проход по AST функций и вычисление типов выражений
- проверки совместимости типов операций, аргументов, веток.

При ошибках типов выбрасывает `TypeError`, который ловится в `Program.fs` и печатается пользователю.

### Интерпретатор (Interpreter.fs)
Основные сущности:
- `Value` – значения во время исполнения:
- `IntVal`, `RealVal`, `BoolVal`, `StringVal`, `ListVal`, `FunctionVal`
- `FunctionClosure` – либо пользовательская функция с окружением, либо встроенная
- `EvalEnv` – окружение с картами переменных, функций и встроенных функций.

Содержит:
- `evalExpr` – вычисление выражений
- `applyUserFunc` и работа с кусочными функциями
- рекурсивные вызовы (функции доступны в окружении по имени для самовызова).

### Встроенные функции (Builtins.fs)
Определяет: константы, функции, операции над списками, функции ввода-вывода.\
Также есть утилита valueToString для вывода результатов.

### Запуск программы (Program.fs)

Главный модуль:
1) читает исходный текст `.ms`
2) парсит его в `Program` через `pProgram`
3) выполняет `checkProgram` для статической проверки типов
4) создает окружение с встроенными функциями
5) выполняет `evalProgramWith` и вызывает `main()`, печатая результат.
